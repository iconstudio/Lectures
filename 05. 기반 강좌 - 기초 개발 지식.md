# 05. 기초 개발 지식

## 게임의 기본 구성 요소

 게임은 여러 구성 요소들의 서로 간의 상호 작용에 의해 동작합니다. 이 상호 작용의 과정은 전적으로 게임을 개발하는 도구, 엔진에 의해 결정됩니다. 그 중에서도 `GameMaker`는 꽤나 단순한 엔진에 속합니다. `GameMaker`에서는 객체 (Object)라는 물건들이 게임 내에서 온갖 일을 합니다. 객체는 어떤 사물을 컴퓨터 안에서 구현한 거라고 보시면 됩니다. `GameMaker`는 객체 지향 엔진이라는 것을 표방하여 이 객체들끼리 상호 작용을 주 작동 원리로 삼고 있습니다. 예를 들어서 사람의 입력을 받아서 움직이는 플레이어도 객체이며, 플레이어 주변에 돌아다니는 NPC도 객체, 플레이어가 밟고 있는 땅도 객체입니다.

 그리고 이 객체들이 활동하는 공간을 룸 (Room)이라고 합니다. 그리고 객체의 겉모습을 이루는 그림과 그 그림의 속성의 집합을 스프라이트 (Sprite)라고 합니다. 객체와 룸은 필수적인 요소로서 둘 중 하나가 없으면 프로그램이 제대로 동작하지 않습니다. 스프라이트는 단순히 그림일 뿐이라 정말 기본적인 요소는 아니지만 일반적으로는 꼭 필요한 요소로 취급됩니다.

### 스프라이트 편집기

[IDE에서 스프라이트 부분이 강조된 사진]

[IDE에서 스프라이트를 하나 만든 사진]

[스프라이트 편집기의 각 요소들을 설명하는 사진]



#### 그림 불러오기

[파일 탐색기에서 그림 파일 하나를 선택한 사진]

[스프라이트 편집기에서 그림을 불러온 사진]



#### 용지 크기 바꾸기

[스프라이트 크기 변경 창의 사진에서 용지 속성 강조]



#### 그림 비율 바꾸기

[스프라이트 크기 변경 창의 사진에서 그림 비율 속성 강조]



#### 프레임

[프레임이 여러 개인 스프라이트 사진]

[프레임을 선택한 사진]

[게임 내에서 스프라이트가 재생되는 사진]



#### 그림 편집기

[그림 편집기 사진]



##### 복사 붙이기

[그림 붙이기 시에 붓 사용 사진]

[그림 붙이기 시에 색상 변경 사진]



### 객체

 객체는 다양한 속성을 가지고 있습니다. 주 스프라이트를 가질 수 있고, 레이어에 놓일 수 있으며, 이동, 이미지, 물리 등 다양한 분야의 속성을 포함하고 있습니다. 여러분이 당장 쓰지 않더라도 `GameMaker`는 이러한 속성들을 준비해놓고 있습니다. 객체가 가질 수 있는 요소는 속성 뿐만이 아닙니다. 객체는 어떤 행동도 하게 만들 수 있습니다. 초기화, 게임 흐름 관리나 다른 객체와의 충돌과 상호 참조 같은 상호 작용 등이 그렇습니다.

#### 스프라이트 할당

 바로 IDE에서 객체의 주 스프라이트를 정해 줄 수 있습니다. 주 스프라이트는 게임에서 객체가 나타나는 겉모습을 의미합니다. 어떤 특별한 동작을 지정해주지 않으면 주 스프라이트가 항상 객체를 대표하는 그림이 됩니다. 주 스프라이트는 게임 도중에도 변경이 가능합니다.

####  이벤트

 객체가 어떤 행동을 하게 만들려면 단순하게 객체의 속에 내용물을 채우는 것이 아닙니다. 다른 엔진이나 프로그래밍 언어들을 보시면 알겠지만, 보통 이런 객체 역할을 하는 클래스는 단 한번 씩만 실행되는 생성자와 소멸자, 그리고 엔진에서 사용하는 각종 상황 별 함수를 갖고 있습니다. `GameMaker`도 마찬가지입니다.

 객체의 동작을 정해 줄 때는 동작 별로 범주가 있고, 각각의 동작을 다르게 제어해야 합니다. 이 범주를 **이벤트 (사건)**라고 부릅니다. 이 이벤트는 단 한번만 실행되는 것이 있고, 실시간으로 실행되는 것이 있고, 혹은 원할 때 실행시킬 수 있는 것도 있습니다. 다음 여섯 개의 이벤트는 저희가 자주 사용할 이벤트입니다. 잘 숙지해두세요.

##### 생성 이벤트

 이 이벤트는 생성자 역할을 합니다. 이 이벤트는 객체가 룸에 생성될 때 딱 한번 실행됩니다. 다른 이벤트 중간에 객체가 생성될 때에도 이벤트 순서에 상관없이 한번 실행됩니다. 보통은 객체에 필요한데 여러 번 실행되면 안되는 변수 선언이나 각종 속성 초기화에 이용됩니다.

##### 스텝 이벤트

 매 초마다 일정 수만큼 실행되는 이벤트입니다. `GameMaker` 기본 설정에선 초 당 60번 실행됩니다. 실시간으로 작동한다고 생각하시면 됩니다.

##### 알람 이벤트

 사용자가 지정한 시간 뒤에 자동으로 실행되는 이벤트입니다. 알람은 총 10개가 있습니다.

##### 입력 이벤트

마우스, 키보드, 제스처 (손짓)입력을 받아올 수 있는 이벤트입니다.

- 마우스 이벤트는 객체를 직접 클릭했을 때, 아무 곳이나 클릭했을 때로 나뉘어져 있습니다. 그리고 누르고 있는 중, 방금 눌렀음, 누르고 있다가 뗌으로 종류가 구분되어 집니다.
- 키보드 이벤트는 일반적인 키보드의 모든 키에 대응됩니다. 그리고 누르고 있는 중, 방금 눌렀음, 누르고 있다가 뗌으로 종류가 구분되어 집니다.
- 제스처 이벤트는 마우스 이벤트와 비슷하게 동작합니다. 제스처 중에 터치, 탭과 더블 탭이 있는데 모바일 환경이 아니라면 이 셋은 마우스 클릭, 더블 클릭과 같습니다.

##### 충돌 이벤트

 이 이벤트를 갖고 있는 객체가 이 이벤트의 대상이 되는 객체와 닿았을 때 실행되는 이벤트입니다. 총알의 피격, 물리적인 충돌 효과, 플랫포머 게임에서 플레이어가 발판을 내딛을 때 등 다양한 곳에서 실행되는 이벤트입니다.

##### 그리기 이벤트

 `draw_*` 함수들을 사용할 수 있는 이벤트입니다. 게임의 시각적 요소는 객체의 스프라이트만 있는 게 아닙니다. 이 이벤트에서도 무언가 따로 그려서 표시해 줄 수 있습니다. 정확히는 이 이벤트에서만 각종 시각적 표현 기능들을 사용할 수 있습니다. 자세한 내용은 추후 강좌에서 설명해드리겠습니다.

### 룸

[도움말에서 룸 사진]

 객체가 게임 구동의 핵심 역할이고, 스프라이트가 객체들의 외향을 담당한다면, 룸은 이 객체들이 활동하는 무대입니다. 또한 게임 창의 겉모습도 겸합니다. 별도의 조치를 취하지 않는다면, 룸의 크기가 곧 게임 창의 크기입니다. 그리고 룸에는 창의 크기 말고도 수많은 속성을 갖고 있습니다.

#### 레이어

[도움말에서 레이어 사진]

 `GameMaker`는 룸 마다 **레이어**라는 것을 여러 개 갖고 있습니다. 이 레이어는 층이라는 뜻을 갖고 있는데, 이름대로 층처럼 쌓여서 객체 들이나, 배경, 타일, 스프라이트 등이 놓일 높낮이를 정할 수 있습니다. 이 레이어는 더 추가할 수도, 지울 수도 있습니다. 이 레이어는 수요가 있을 때마다 만드는 게 좋습니다. 구분이 필요할 때 즉각 나누는 게 좋다는 말입니다.

#### 객체 배치

[객체가 놓인 룸의 사진]

 객체의 배치는 먼저 룸 편집기를 여는 것으로 시작합니다. 모든 객체는 자기가 위치한 레이어가 있어야 하기 때문에 룸에 객체를 놓을 때에도 레이어를 정해줘야 합니다. 룸 속성의 레이어 목록에서 레이어를 하나 선택하면 됩니다. 그리고 자원 목록에서 놓을 객체를 선택하고, 룸 에디터 상의 원하는 위치에서 Alt키와 마우스를 눌러 줍시다. 이렇게 하면 마우스 위치에 객체가 하나 배치되게 됩니다. 이렇게 배치된 객체의 목록은 룸 속성에서 확인하실 수 있습니다. 또한 객체를 지울 때는 객체 목록에서 선택해서 지우거나, 룸 상의 객체를 선택해서 Delete를 눌러 지울 수 있습니다.

[룸에 놓인 객체의 속성을 바꾼 사진]

 룸에 객체를 놓을 때도 객체들의 속성을 지정해 줄 수 있습니다. 가령 image_angle, image_blend 등을 미리 정해줄 수 있습니다. 이렇게 하면 코드 편집기에서 내장 변수를 수정하고 실행하면서 번거롭게 결과물을 확인할 필요 없이 그냥 룸 편집기에서 바로 결과물을 확인할 수 있다는 장점이 있습니다.

 방금 룸 편집기에서 했던 일련의 과정들이 잘 이해가 안되실 수 있습니다. 사실 `GameMaker`의 룸 편집기가 조금 불친절한 편입니다. 하지만 중요한 것은 차근차근 알아 가는 것, 그리고 항상 상황을 확인하는 것입니다. 레이어를 잘못 골라서 객체가 이상한데 놓였다면 레이어 목록을 뒤져볼 필요 없이 룸 상에서 객체를 직접 확인하면 됩니다. 작은 객체가 큰 객체 아래에 깔려서 안 보인다면 마우스로 드래그하여 선택해서 확인한 후에 레이어의 객체 목록을 확인하면 됩니다. 적어도 편집기 안에서 생긴 문제는 편집기 내에서 해결할 수 있습니다. 명심하세요.

## 게임 실행 방법

게임 실행 방법 설명

## 프로그래밍

 `GameMaker`는 독자적인 프로그래밍 언어를 사용합니다. 바로 `GameMaker Language (GML)`이라는 스크립트 언어입니다. 프로그래밍을 따로 공부하신 분들께 미리 말씀드리자면, 이 언어는 정말 자바스크립트와 비슷합니다. 오래전, `GameMaker`의 창조자 마크 오버마스가 다른 스크립트 언어 `Delphi (델파이)`에서 따와 만들었을 때부터 자바스크립트도 참고하지는 않았을 것 같습니다. 그때는 AJAX도 없었을 때니까요. 하지만 자바스크립트를 배우신 분이라면 비슷한 방식으로 코딩하실 수 있습니다. 이상하게도 `C`랑 비슷하다고 말이 옛날부터 있었는데, `GML`은 자바스크립트랑 원조 격인 델파이 말고는 닮은 언어도 없습니다.

 `GML`은 정말 간단하고 쉬운 언어입니다. `GameMaker`의 모토인 빠르고 간단한 게임 개발에 걸맞은 언어입니다. 통신과 모바일 분야에서는 문제 많은 확장 기능의 힘을 빌어야 하는 단점이 있지만, 그 외엔 아무 무리 없이 개발 진행이 가능합니다.

 으레 개발의 첫 시작은 "Hello World!"를 띄우는 것이었습니다. 사실 `GameMaker` 첫 예제는 그런 게 아니었고, 아케이드 게임 시연 예제였습니다. 그래도 메시지 출력이 당장 뭔가 보여 주는 데는 좋습니다.

### 문자 출력

- `show_message(caption: 출력할 내용)`
  `show_message`는 `GameMaker`에서 간단하게 값이나 문자를 출력하는데 사용하는 함수입니다. 게임 내부에서 보여 주는 건 아니고, 게임 창 위에 메시지 창을 띄웁니다. 게임 내부에서 사용할 수 있는 함수는 다음 강좌에서 설명해드리겠습니다.

``` js
// "Hello World!" 출력
show_message("Hello World!")
// "Is anyone there?" 출력
show_message("Is anyone there?")
// 12345 출력
show_message(12345)
```

`show_message`는 메시지 창을 띄운 동안에는 게임을 일시 정지 시킵니다. 이를 이용하여 일시 정지에 이용할 수 있습니다. 하지만 더 좋은 방법이 있으므로 권장해드리지는 않습니다. 그리고 한번에 여러 개의 메시지를 띄우면 실행한 순서대로 순차적으로 띄웁니다.

### 변수

 주변의 사물을 보면 아시겠지만, 물체들은 떨어진다, 난다, 열린다 등 행동과 겉모습 외에도 딱딱하다, 무겁다, 어떤 작은 물체 여러 개로 이루어져 있다, 빛난다, 퍼져나간다 등의 속성을 갖고 있죠. 프로그래밍 언어에도 이런 객체마다 어떤 정보를 담고 있는 요소가 있습니다.

 `GameMaker`에도 이런 정보를 저장할 때 유용하게 이용할 수 있는 게 있습니다. 바로 **변수 (variable)**라고 부르는 요소입니다. 이 변수는 여러분이 그 내용을 마음대로 조작할 수 있습니다. 프로그래밍 언어에선 어떤 값들을 이름도 없이 아무 데나 두고 쓸 수 없습니다. 사용자의 목적대로 값들을 어떤 장소에 두고 써야 합니다. 이 변수가 그런 값들을 담는 항아리 같은 역할을 합니다. 이름은 **변하는 수**지만, 사용자가 다시 조작하지 않으면 변수에 담긴 내용은 변하지 않습니다. 

 변수의 선언은 `variable = value`의 형태로 이루어집니다. 한번 선언하면 계속 남아있습니다. 하지만 특수한 경우를 제외하면 한 변수는 선언해 준 객체에서만 사용이 가능합니다. 주의하실 점은 변수 선언이 어떤 이벤트에서 됐다고 하더라도, 그 이벤트보다 먼저 변수를 사용하면, 변수 선언이 되지 않았다는 오류가 발생한다는 것입니다. 한 객체 내에서 두고두고 쓸 변수는 처음에 전부 선언하는 것이 좋습니다.

### 내장 변수

 모든 객체는 사용자가 만들지 않았지만, 미리 필요할 것 같은 변수를 선언해둔 것을 갖고 있습니다. 이런 변수들을 내장 변수 (Builtin Variable)라고 부릅니다. `GameMaker`에는 이런 변수들이 수백 개가 있습니다. 여러분이 도움말에서 직접 쓰임새를 찾아 쓰실 수도 있습니다.

#### 좌표

[도움말에서 좌표 사진]

- `x`: 실수
- `y`: 실수

이 두 변수는 룸 안에서 객체의 위치를 나타냅니다. 이 두 변수가 조합되어 객체의 위치가 정해지는 것입니다. 각기 따로 쓰면 그냥 숫자와 다를 것이 없습니다. 좌표는 음수거나 룸의 너비, 높이보다 커져서 아예 객체가 룸 밖으로 나갈 수도 있습니다. 즉 단순히 룸의 크기는 보여지는 창에 영향을 미칠 뿐 객체의 좌표에 제한을 두진 않습니다. 그래서 빠른 속도로 이동하는 총알 객체들은 룸 밖으로 나갈 수도 있습니다. 그런데 이렇게 눈에 보이지 않는 객체가 쌓이면 어떻게 될까요? 이에 관해서는 추후 강좌에서 알려드립니다.``

#### 속도와 방향

[도움말에서 속도와 방향 사진]

speed, direction

#### 각도

[도움말에서 각도 사진]

image_angle

#### 크기

[도움말에서 비율 사진]

image_xscale, image_yscale

### 조건 분기

if 문, < > == <= >

true, false

### 객체 생성 및 제거

instance_destroy, instance_create_layer 설명

### 제어

- id

- with, other

### 기타

#### 무작위 값

- random

- irandom

#### 두 지점 사이의 각도

- point_direction

#### 게임 다시 시작

- game_restart

#### 게임 종료

- game_end

## 예제

 이제 몇 가지 예제를 보여드리겠습니다. 프로젝트로의 구현은 여러분에게 맡깁니다.

### 간단한 문자 출력

```js
// 4개의 메시지를 연달아서 출력
show_message("")
show_message("")
show_message("")
show_message("")

// 조건 분기를 활용한 다른 메시지 출력
if show_question("이럴 때 당신은 무엇을 해야하는가?", "fireball!", "fireball!") {
	show_message("불구!")
} else {
    show_message("부레구!")
}

// 마지막 메시지 출력 이후 게임 종료
show_message("")
game_end()
```

### 여러 개의 객체 생성

```js
/*
	레이어 기반의 객체 생성.
*/
instance_create_layer(0, 0, "System", oGameGlobal)
instance_create_layer(80, 390, layer, oBuilding)
instance_create_layer(220, 320, "Wall", oMountain).image_xsacle = 1.5

/*
	깊이 기반의 개체 생성. 사용하지 않는 것이 좋다.
*/
instance_create_depth(x, y, 10, oShadow)
```

### 총알을 쏘는 플레이어 oPlayer 구현

- 플레이어 객체 oPlayer와 총알 객체 oBullet이 필요합니다.

```js
/* oPlayer 생성 이벤트 */
reloaded = true

/* oPlayer 스텝 이벤트 */
// 플레이어가 마우스를 바라보게 만들기
image_angle = point_direction(x, y, mouse_x, mouse_y)

/* oPlayer 알람 0 이벤트 */
reloaded = true

/* oPlayer 마우스 왼쪽 누르기 이벤트 */
if reloaded {
    with instance_create_layer(x, y, layer, oBullet) {
        speed = 10
        direction = other.image_angle
    }
    
    reloaded = false
    alarm[0] = 5
}
```

### 레이어를 이용한 객체 구분

[IDE 내의 게임 자원 목록 사진]

[두 포탑 객체가 적에게 총알을 발사하는 게임 사진,  그림자가 있음]

 구현이 잘된 것 같아 보이는 디펜스 게임의 사진입니다. 그런데 뭔가 이상하군요. 게임의 동작이 아닌 시각적으로 뭔가 문제가 있어 보입니다. 그림자가 들쭉날쭉하고 표기되는 글자들이 포탑보다도 밑에 있습니다.

```js
// 원래 소스는 그림자, 총알과 적을 모두 같은 레이어에 생성한다.
with instance_create_layer(50, 100, layer, oEnemy) {
    speed = 2
    direction = 270
}

with instance_create_layer(x, y, layer, oBullet) {
    speed = 8
    direction = other.image_angle
}

with instance_create_layer(x, y, layer, oShadow) {
    sprite_index = sShadowTurret
    parent = other.id
}
```

 여러 객체에서 사용하는 코드를 모은 것입니다. 상단의 코드에서 알 수 있듯이 모든 `instance_create_layer` 함수들이 같은 레이어를 사용하고 있습니다. 왜냐하면 적을 만드는 시스템 객체, 총알을 발사하는 포탑 객체, 그림자를 만드는 모든 객체들이 룸에서 같은 레이어에 놓여있었기 때문입니다.

[룸에 레이어 여러 개를 만든 사진]

 모든 객체 종류별로 레이어를 분화합니다. 이 예제에서는 "System", "Turret", "Enemy", "Bullet", "Shadow", "Background" 순으로 나눴습니다. 그리고 시스템 객체를 "System" 레이어로 옮겨 주고, 포탑 객체를 "Turret" 레이어로 옮겨 주어야 합니다. 그런데 룸에서만 객체를 옮긴다고 문제가 해결되는 것은 아닙니다. 여러분이 이렇게 고치고 실행을 해보시면, 여전히 그림자 일부가 이상하게 보이는 문제가 있을 겁니다. 코드에서 사용되는 레이어도 고쳐 주셔야 합니다. 레이어의 사용에 익숙해지시길 바랍니다.

```js
// 이제 그림자, 총알, 포탑, 적 모두가 다른 레이어에 있다.
with instance_create_layer(50, 100, "Enemy", oEnemy) {
    speed = 2
    direction = 270
}

with instance_create_layer(x, y, "Bullet", oBullet) {
    speed = 8
    direction = other.image_angle
}

with instance_create_layer(x, y, "Shadow", oShadow) {
    sprite_index = sShadowTurret
    parent = other.id
}
```

[실행해서 각 객체들이 구분된 사진]

 완성되었습니다.